最近在学Android应用开发课程，想到刘女士店里订单和账目管理总是乱成一团，于是打算自己设计一个订单管理系统，既是为了学习，也可能为刘女士和她的业界同行解决账目管理的杂事。

鉴于本人是个菜鸟加编程麻瓜，记录一下学习过程还是很有必要的。

# 一、产品需求

在设计一个Android应用之前，首先应该明白产品需求。

# 二、技术栈

# 三、曲折前进（开发日志）

## 3.29

### 1. 网络问题

国内开发，网络问题是大事，尤其是在一个新手刚下载好Android studio，雄赳赳气昂昂新建一个项目“hello，Android！”，却惨遭失败时，实在是万分打击自信心！接下来就只好一步步排查，解决网络问题！

- 1. 首先，确认代理工具运行正常、端口正常；
  2. 在Android Studio：

  - “File > Settings > HTTP Proxy”。

  - 选“Manual proxy configuration”。

  - 输入Host（网络配置的host是什么？现在的我也不知道！）和port，勾选“Authentication”，填入用户名和密码（如果需要的话）。

  - 测试https://dl.google.com，确保“Connection successful”。

​	3. 点击“Sync Project with Gradle Files”。

但是！实际上到这里网络问题还没有完全解决，大多数时候，我们还需要点开根目录下的“gradle.properties”，配置一番，对我来说，是这样的：

```
systemProp.http.proxyHost=127.0.0.1
systemProp.http.proxyPort=7897
systemProp.https.proxyHost=127.0.0.1
systemProp.https.proxyPort=7897
```

 这样配置完成后，再同步一下各文件（这里或许不太对，其实我现在也还不太明白同步到底是在同步些什么[笑哭]），就可以构建成功了！看见终端上的库库上涨的进度条，成就感爆棚啊（虽然这只是很小的一步）！

### 2. 学到点什么（Android studio的文件结构）



### 3.添加依赖

我们的目的：引入Room、LiveData和RecyclerView所需的库，MVVM架构依赖这些组件。

这又是一番苦战！我先说说遇到了什么问题吧！

1. 依赖声明的方式不一致问题
    我添加的依赖（如 implementation "androidx.room:room-runtime:2.6.1"）使用的是传统的字符串     形式，而项目中已有的依赖（如 implementation(libs.androidx.core.ktx)）使用的是 Gradle 的 libs     引用方式（通常来自 gradle/libs.versions.toml 文件）。这两种方式混用可能导致配置解析错误。
    （我现在也不理解两种依赖声明方式的原因，以及用libs引用方式声明的优越性）
2. 插件版本与依赖不兼容

我的解决方法：
1. 清理 Gradle 缓存：删除 C:\Users\21117\.gradle\caches 并重新构建，可能清除了之前导致插件版本冲突的遗留数据。
2. 修正配置：确保 settings.gradle.kts 中的 pluginManagement 和 gradle/libs.versions.toml 中的版本定义一致，避免了 Gradle 从其他来源加载未知版本的插件。
3. 插件声明一致性：在 app/build.gradle.kts 中正确使用 alias(libs.plugins.kotlin.kapt)，并避免手动指定版本，保持版本管理的统一性。

同时grok给了我后续建议，我也在这里留一下：
> 为了避免类似问题再次发生，这里有一些建议
> 1. 定期清理缓存：
>    Gradle 缓存有时会保留旧数据，导致奇怪的构建问题。可以在项目出现异常时运行：
>    ./gradlew cleanBuildCache
>    rmdir /s /q C:\Users\<YourUsername>\.gradle\caches
> 2. 版本管理规范化：
>    始终通过 gradle/libs.versions.toml 管理插件和依赖版本，避免在 build.gradle.kts 中硬编码               版本号。定期检查 Gradle 和插件版本是否需要更新（例如 Kotlin 2.0.21 是最新吗？AGP 8.9.0             是否有新版本？）。
> 3. 验证配置：
>    每次修改 Gradle 配置文件后，运行 ./gradlew build --info 检查是否有警告或错误。
>    使用 Android Studio 的 “Sync Project with Gradle Files” 功能，确保 IDE 和命令行构建一致。
> 4. 备份项目：
>    在大改动（如升级 Gradle 或插件版本）前，备份项目文件或使用 Git 提交，方便回滚。



### 4. 学到点什么（Android studio不同视图代表什么）



### 5. 学到点什么（一些命令）

>  ./gradlew build --debug > debug.log

运行更详细的日志。

> ./gradlew cleanBuildCache
>
>  ./gradlew clean

清理项目构建

> ./gradlew build --stacktrace --info

重新同步并构建。

### 6. 学到点什么（一些库的简介）

**Room**：轻量级数据库，用于存储订单数据。

**LiveData**：响应式数据观察者，自动更新UI。

**RecyclerView**：显示订单列表。

**Kapt**：Kotlin的注解处理器，Room需要它生成代码

### 7. 阶段性成果（依赖添加成功！）

接下来我们就要创建订单的数据结构和Room数据库，用于存储和查询订单了！

### 8. 规划文件结构

在app/src/main/java/com.example.ordermanager下创建以下包：

- data：存放数据库和实体类。
- model：定义订单数据模型。
- ui：存放Activity和Fragment。
- viewmodel：存放ViewModel。

不过，我现在还不知道model、viewmodel是什么。

示例结构：

```text
com.example.ordermanager
├── data
│   ├── OrderDao.kt
│   ├── OrderDatabase.kt
├── model
│   ├── Order.kt
├── ui
│   ├── MainActivity.kt
│   ├── OrderListFragment.kt
│   ├── AddOrderFragment.kt
├── viewmodel
│   ├── OrderViewModel.kt
```

### 9. 定义数据模型和数据库

目的：创建订单实体和Room数据库，用于存储和管理订单数据。

#### 9.1 定义订单实体类

订单实体类是什么？我们需要有哪些订单实体类？我看到在新建Kotlin文件中，有很多新建选择，这些是什么？

![image-20250329180728497](C:\Users\21117\AppData\Roaming\Typora\typora-user-images\image-20250329180728497.png)

在文件app/src/main/java/com.example.ordermanager/model/Order.kt中编写代码，我创建了一个名字叫order的数据库实体。

#### 9.2 创建DAO接口

在app/src/main/java/com.example.ordermanager/data/OrderDao.kt文件中写代码用于定义数据库操作。

所谓DAO接口是什么？

数据库访问接口

![image-20250329184609471](C:\Users\21117\AppData\Roaming\Typora\typora-user-images\image-20250329184609471.png)

#### 9.3 创建数据库类

创建数据库类是什么意思？为什么要创建数据库类？

在文件app/src/main/java/com.example.ordermanager/data/OrderDatabase.kt中创建数据库类

### 10. 实现ViewModel

目的：使用ViewModel链接UI和数据层，管理订单的添加和列表显示。









## 3.31

### 1. 学习（MVVM架构）

[应用架构指南]: https://developer.android.com/topic/architecture?hl=zh-cn

### 2. 学习（一些概念：）

界面UI：应用的界面UI就是在屏幕上所看到的内容（文本、图片、按键和许多其他类型的元素）及其在屏幕上的布局方式，它既是应用向用户显示内容的方式，也是用户与应用展开互动的载体。

Jetpack Compose：用于构建Android界面的新款工具包。Compose 使用更少的代码、强大的工具和直观的 Kotlin 功能，可以帮助您简化并加快 Android 界面开发。借助 Compose，您可以通过定义一组函数来构建界面，这些函数称为可组合函数，它们会接受数据并描述界面元素。

可组合函数：在Compose中，可组合函数使界面的基本构建块。

- 描述界面中的某一部分
- 不会返回任何内容
- 接受一些输入并生成屏幕上显示的内容

可组合函数：

1. 带有@Composable注解，所有可组合函数都必须带有此注解，此注解可告知Compose编译器：此函数用于将数据转换为界面（编译器：一种特殊的程序，它会接受编写的代码，逐行查看，然后将其转换成计算机可以理解的指令）
2. [可组合函数名称](https://github.com/androidx/androidx/blob/androidx-main/compose/docs/compose-api-guidelines.md#naming-unit-composable-functions-as-entities):使用Pascal命名法，所有单词的首字母都大写

注解：

1. 用于在代码中附加额外信息的方式，可以帮助 Jetpack Compose 编译器等工具和其他开发者理解应用的代码。

2. 如果要使用注解，需要在注解的声明开头为其名称添加@字符作为前缀。
3. 可以为包括属性、函数和类在内的不同代码元素添加注解。
4. 有哪些注解？
5. 注解可以接受形参（有哪些可以接受的形参？）、可以传递多个实参

Android studio中的“Design”窗格

1. 可组合函数必须为所有形参提供默认值，才能对其进行预览，需要添加另一个函数，由这个函数使用适当的形参调用被定义的可组合函数
2. 使用@Preview注解添加到函数中的代码仅用于在design窗格预览，这些更改不会体现在应用中

### 3. 学习（添加新的文本元素）

1. Modifier形参和子元素：
2. 在可组合函数GreetingText()中，添加一个Text可组合想，并传入文本消息作为具名实参

```kotlin
@Composable
fun GreetingText(message: String, modifier: Modifier = Modifier) {
    Text(
        text = message
    )
}
```

### 4. 学习（更改字体大小）

1. Android应用中的界面元素使用两种不同的度量单位：SP（可缩放像素）和DP（密度无关像素）
2. sp是Int的扩展属性，用于创建sp单位，同样，也可以在Float和Double等其他数据类型中使用.sp扩展属性
3. 更新Text可组合项以包含行高

### 5. 学习（再添加一个文本元素）

![image-20250331193941066](C:\Users\21117\AppData\Roaming\Typora\typora-user-images\image-20250331193941066.png)

### 6. 学习（将可组合项排列成一行或一列）

1. 界面层次结构
   1. 界面层次结构基于包含机制，意思就是说，一个组件可以包含一个或多个组件
   2. 可用作父界面元素的Column、Box、Row可组合项
2. 尾随lambda语法（？还是有点不解，但是我们先知道怎么用就行！）
   1. Row可组合函数中使用的是花括号而不是圆括号，这称为未遂lambda语法；
   2. 将函数作为形参传递时，可以使用尾随lambda语法

### 7. 向应用添加问候语

“最好从父级可组合项传递修饰符属性和修饰符。”

这句话是 Jetpack Compose 中关于 Modifier 使用的一个最佳实践建议。它的意思是，在构建 UI 组件时，**应该优先从父级可组合项（Parent Composable）传入 Modifier 参数，而不是在子级可组合项中直接硬编码修饰符**。同时，父级传入的 Modifier 应该被传递并应用到子级中的适当位置。

一个简单的可组合项如下：

```kotlin
@Composable
fun MyText() {
    Text(
        text = "Hello",
        modifier = Modifier.padding(16.dp) // 硬编码的 padding
    )
}
```

改进后的写法：

```kotlin
@Composable
fun MyText(modifier: Modifier = Modifier) {
    Text(
        text = "Hello",
        modifier = modifier // 从父级传入并应用
    )
}
```

这样，父级可以自由传入修饰符：

```kotlin
@Composable
fun Screen() {
    MyText(modifier = Modifier.padding(8.dp))
}
```

从父级传入修饰参数，并将其应用到子级的主要元素，而不是在子级内部写死修饰符，这样可以提高复用性、一致性和代码可维护性

### 8. 扩展的尾巴（了解详情）

[可组合项](https://developer.android.com/reference/kotlin/androidx/compose/runtime/Composable?hl=zh-cn)

[Compose布局基础知识](https://developer.android.com/jetpack/compose/layouts/basics?hl=zh-cn)

[像素密度](https://m3.material.io/foundations/layout/understanding-layout/spacing#28f7a086-b6f7-4120-b18f-02a5fa5adbb5)

[Compose中的文字](https://developer.android.com/jetpack/compose/text?hl=zh-cn)

[Kotlin对Jetpack Compose的支持](https://developer.android.com/jetpack/compose/kotlin?hl=zh-cn)

### 9. 向Android应用添加图片

## 4.1 

### 1. 一个差异

grok告诉我，要建立四个package，

### 2. 文件介绍在工作中一般放在哪里？

### 3. Kotlin接口是什么？

### 4. 什么是异步执行、挂起函数、Kotlin Coroutines、异步返回查询结果？

### 5.schema是什么？

### 6. 我们如何使用Room（简单介绍）

为了简化Android上的数据库操作，Google推出了Room持久化库，它并不是一个新的数据库，而是SQLite的抽象层。

今天我在代码中创建的三个组件就是使用Room的核心：

1. `@Entity`（Order.kt）
   1. 作用：用于定义数据库中的表结构
   2. 使用方法：使用`@Entity`注解标记`Order` data class，告诉 Room：“嘿，我想创建一个名为 orders 的表，它有 id, orderNumber, customerName, amount 这几列，其中 id 是主键并且自动增长。” 
   3. Room会根据这个类自动生成创建表的SQL语句
2. `@Dao`(OrderDao.kt)
   1. 作用：定义数据访问操作（Data Access Operations），这是我们与数据库交互的接口
   2. 使用方法：我们创建了一个接口`OrderDao`并用`@Dao`注解，里面的方法定义了我们要执行的操作：
      1. @Insert: 告诉 Room 如何插入一个 Order 对象。
      2. @Query("SELECT ..."): 告诉 Room 如何执行查询。我们写 SQL 查询语句，但方法的参数和返回值可以是 Kotlin 类型（如 Int, Flow<List<Order>>）。Room 会处理 SQL 执行和结果转换。
      3. `suspend`：因为数据库操作可能耗时，不能再主线程上进行，我们只用suspend关键字标记这些方法，表示它们应该在协程中异步执行
      4. `Flow`：getAllOrders() 返回 Flow<List<Order>>。Flow 是 Kotlin 协程库中的一个类型，它可以**异步地**、**持续地**发送数据流。当数据库中的订单列表发生变化（增、删、改）时，这个 Flow 会自动发出最新的订单列表，非常适合与 LiveData 结合在 UI 上实时更新数据。
3. `@Database`(OrderDatabase.kt)
   1. 作用：数据库持有者。它将Entity和DAO关联起来，是获取DAO实例和实际数据库连接的入口点
   2. 使用方法：我们创建一个抽象类OrderDatabase继承RoomDarabase，并用`@Database`注解
      1. entities = [Order::class]: 指定这个数据库包含哪些表（由哪些 Entity 定义）。
      2. version = 1: 数据库的版本号。如果以后修改了表结构（比如给 Order 添加一个新字段），需要增加版本号并提供迁移策略（我们用了简单的 .fallbackToDestructiveMigration()，表示升级时直接删除旧表重建，会丢失数据，实际项目中通常需要更复杂的迁移）。
      3. abstract fun orderDao(): OrderDao: 提供获取 OrderDao 实例的方法。Room 会自动实现这个方法。
      4. companion object 和 getDatabase(): 提供了一个单例模式来获取数据库实例，确保整个应用只使用一个数据库连接，避免资源浪费和潜在问题。

### 7. 巨大问题

按照你前面所说，我需要理解schema，它相当于一张设计图，告诉数据库如何存储和组织数据，我现在做的订单管理系统非常复杂，我该怎么组织？

### 8. 创建Repository

#### 8.1 简单介绍Repository

Repository（仓库）是MVVM架构中推荐的一个组件，它扮演者数据源的统一入口角色，它的主要职责是：

1. 抽象数据来源：ViewModel 不需要关心数据是来自本地数据库 (Room)、网络 API 还是内存缓存。ViewModel 只跟 Repository 交互，由 Repository 决定从哪里获取数据以及如何存储数据。
2. 提供清晰的API：他为ViewModel提供了一组清晰、简洁的数据操作接口（比如`getAllOrders`, `insertOrder`）。
3. 分离关注点：将数据操作逻辑（如何获取、存储、缓存数据）与ViewModel的业务逻辑（处理用户交互、准备UI数据）分离开来，使得代码更清晰、更易于测试和维护

在我们的 OrderManager 应用中，目前只有一个数据源：Room 数据库。但 Repository 模式为未来扩展（比如从服务器同步订单）提供了良好的基础。

#### 8.2 创建OrderRepository类



## 4.3 正式进入应用的开发

确切地说，前面只是一个我们在适应Android应用开发的过程，之后的操作才是要深入开发的核心。

### 1. 再次调整设计步骤

1. 需求梳理与数据库设计

2. 集成Hilt

   - 添加Hilt依赖、配置Application、注解Activity/ViewModel
   - 创建Hilt Modules来提供AppDatabase实例、OrderDao实例以及即将创建的CustomerDao实例
   - 创建或修改 Repository，并通过 Hilt 注入 DAO。
   - 修改 ViewModel，通过 Hilt 注入 Repository。

3. 实现数据库结构与迁移

   设计出能够高效存储和检索数据的底层表结构，而复杂的视图和业务逻辑则在应用层和UI层组装

4. 开发CRM功能、增强订单管理



### 2. 更新和细化数据库设计

## 4.6 

前两天有点忙于写报告了，现在有点时间，来继续我的项目吧！

### 1. 学（Android应用开发各层间关系）

ViewModel：是MVVM架构中的一部分，负责管理UI层的数据和逻辑。它是一个桥梁，把数据从后端（比如数据库或者网络）传递给界面，同时保证数据在屏幕旋转等配置变化时不会丢失。

Repository：是一个中间层，负责协调和管理数据的来源，它可以从数据库、网络或其他地方获取数据，然后提供给ViewModel；

- 它抽象了数据来源的细节，让ViewModel不需要关心数据到底是从数据库来的还是从网络来的，它是“单一数据来源”的核心

DAO（Data Access Object）：是一个接口，用于定义如何操作数据库中的数据，比如增删改查，它是Room数据库的一部分（TODO：其它数据库和数据来源有吗？）

- 它提供了一组方法，让你可以用简单的Kotlin代码来操作数据库表，而不需要写复杂的SQL

Database：是Room的核心，通常是一个抽象的类，里面定义了数据库结构和DAO实例。

- 它负责创建和管理数据库实例，并提供对DAO的访问入口，Room会根据用户的定义自动生成底层的SQLite代码

MVVM架构：

- Model：数据层，包括Repository、DAO和Database，负责数据存储与获取
- View：界面层，使用Jetpack Compose实现，显示数据并接收用户的输入
- ViewModel：中间层，连接Model和View，管理数据和业务逻辑

在我们的技术栈中，安卓应用的架构可以分为以下几层：

- UI层（View）
  - 技术：Jetpack Compose
  - 职责：显示数据、处理用户交互（点击、输入等）。
- 视图模型层（ViewModel）
  - 技术：ViewModel（Jetpack组件）
  - 职责：持有UI数据、处理简单的逻辑，响应用户操作。
- 数据层（Model）
  - 子层1-Repository：协调数据来源，提供数据给ViewModel
  - 子层2-DAO和Database：具体操作本地数据库（Room）
  - 其他来源：网络API(这里留个悬念，我们之后可能需要)

- 层间依赖关系：是单向依赖的，从上到下依次依赖，数据流则是双向的
  - UI层依赖ViewModel：UI层通过ViewModel获取数据，并调用ViewModel方法
  - ViewModel依赖Repository：ViewModel不直接访问数据库，而是通过Repository获取数据（比如repository.getUsers()）
  - Repository依赖DAO
  - DAO依赖database

### 2. 集成Hilt实现依赖注入

随着应用功能增多，手动创建和管理这些类的实例及其依赖关系（比如 ViewModel 需要 Repository，Repository 需要 DAO，DAO 需要 Database 实例）会变得非常复杂和容易出错，Hilt可以自动化这个过程。

- 简化依赖注入的配置
- 自动处理 Android 框架类（Activity, Fragment, ViewModel 等）的注入。
- 提高代码的可测试性和可维护性。
- 与 Jetpack 组件（如 ViewModel, WorkManager）无缝集成。

在项目中设置Hilt的步骤：

- 添加 Hilt 相关 Gradle 依赖
- 创建自定义的 Application 类并用 @HiltAndroidApp 注解。
- 修改 AndroidManifest.xml 指向自定义 Application。
- 修改你的 Activity (或 Fragment) 使用 @AndroidEntryPoint 注解。
- 创建 Hilt Module 来提供我们之前定义的 AppDatabase、各个 DAO 的实例以及将要创建的 Repository 实例。
- 修改 ViewModel 使用 @HiltViewModel 注解，并通过构造函数注入 Repository。

 

## 4.7



# 开发遗留问题

## 1. KSP库

在app级别的build.gradle

This library supports using KSP instead of kapt, which greatly improves performance. Learn more: https://developer.android.com/studio/build/migrate-to-ksp





# 问题与疑惑

## 1. Hilt依赖

```kotlin
/*
 * @HiltAndroidApp注解是Hilt设置的起点，会触发Hilt的代码生成，
 * 包括一个附加到我的应用生命周期的依赖容器，、
 * 这个生成的Hilt组件会附加到Application对象的生命周期，并向其提供依赖项
 * 它也是应用中其他Hilt组件的父组件
 */
```

关于Hilt确实是一无所知

在此期间，我同时对















