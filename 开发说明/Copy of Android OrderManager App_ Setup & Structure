**开发规划 (阶段性)：**

**核心原则：**

- **先基础，后扩展：** 先实现核心模块的基本 CRUD (创建、读取、更新、删除)，再逐步增加复杂逻辑和关联功能。
- **数据驱动：** 每个功能模块的实现都离不开对应的数据模型 (Entity) 和数据操作 (DAO, Repository)。
- **UI 与逻辑分离：** 严格遵循 MVVM，保持 UI (Compose)、ViewModel 和数据层 (Repository) 的清晰界限。
- **小步快跑，及时反馈：** 每个小功能点完成后，都进行测试，确保其按预期工作。

------



**阶段一：完善客户管理 (CRM) - 已部分完成**

- 
- 目标：提供完整的客户信息管理能力。
- **已完成：**
  - 
  - 客户列表显示。
  - 基础的客户添加 (通过对话框)。
  - 基础的客户删除 (带确认)。
  - 基础的客户搜索。
- **下一步具体任务：**
  1. 
  2. **客户详情与编辑屏幕：**
     - 
     - **导航：** 从客户列表点击客户项，能够跳转到客户详情/编辑屏幕，并传递客户 ID。 (需要引入 Jetpack Navigation Compose)
     - **ViewModel:** 创建 CustomerDetailViewModel，根据传入的客户 ID 从 CustomerRepository 加载客户信息。
     - **UI:**
       - 
       - 显示客户所有信息 (姓名、电话、地址、备注等)。
       - 提供编辑按钮，点击后变为可编辑状态或跳转到专门的编辑界面。
       - 保存按钮，调用 ViewModel 更新客户信息。
     - **Repository/DAO:** 确保 updateCustomer 方法正常工作。

------



**阶段二：核心订单管理**

- 
- 目标：实现订单的创建、查看、基础信息编辑和状态管理。
- **前置依赖：** 客户管理基本完成（至少能选择客户）。产品目录 (Product Entity 和相关 DAO/Repo/VM) 最好也先有基础。
- **具体任务：**
  1. 
  2. **产品目录基础 (并行或优先)：**
     - 
     - **Entity/DAO/Repo:** Product 实体、ProductDao、ProductRepository (接口+实现)、ProductModule (Hilt 绑定)。
     - **ViewModel:** ProductViewModel (用于管理产品列表、添加/编辑产品)。
     - **UI:** 简单的产品列表界面、产品添加/编辑界面 (名称、分类、型号、默认价格等)。
  3. **订单添加屏幕：**
     - 
     - **导航：** 从某个入口 (如主页、客户详情页) 跳转到订单添加屏幕。
     - **ViewModel:** AddOrderViewModel。
     - **UI:**
       - 
       - 选择关联客户 (从客户列表中选择)。
       - 自动填充客户电话、地址 (允许修改)。
       - 下单日期 (默认为当前，可修改)。
       - **添加订单项 (OrderItem) 动态列表：**
         - 
         - 选择产品 (从产品目录中选择，带出名称、型号、默认单价)。
         - 输入产品数量、实际单价 (允许修改默认单价)、尺寸、颜色、备注。
         - 动态计算每个订单项总金额。
         - 允许添加多个订单项。
       - 计算订单总金额 (所有订单项金额之和)。
       - 输入优惠金额、首付款。
       - 选择订单跟进人 (Staff - 需要先实现基础店员管理)。
       - 订单备注。
     - **数据处理：** ViewModel 接收所有数据，创建 Order 对象和 List<OrderItem> 对象，调用 OrderRepository 保存。
  4. **订单列表与详情屏幕：**
     - 
     - **ViewModel:** OrderListViewModel, OrderDetailViewModel。
     - **UI (列表):** 显示订单列表（订单号、客户名、下单日期、总金额、订单状态）。支持按客户、状态等筛选。
     - **UI (详情):** 点击订单项跳转到订单详情。显示订单所有信息、关联客户信息、所有 OrderItem 列表 (产品名、数量、单价、总价、**当前产品状态**)。
  5. **基础订单编辑与状态更新：**
     - 
     - 在订单详情页提供编辑订单基本信息的功能 (如备注、跟进人，金额类修改需谨慎处理逻辑)。
     - （初步）允许手动更新订单的整体状态 (Order.status - 例如从“处理中”到“已取消”；“已完成”状态的触发依赖产品进度)。

------



**阶段三：产品进度跟进**

- 
- 目标：实现订单中每个产品从“未下单”到“已安装/已回访”的全流程状态跟踪。
- **前置依赖：** 核心订单管理完成（能创建订单和订单项）。
- **具体任务：**
  1. 
  2. **OrderItem 状态更新逻辑：**
     - 
     - **ViewModel/Repository/DAO:** 确保有更新 OrderItem.status、记录 statusLastUpdateStaffId、statusLastUpdateAt 以及各阶段时间戳 (orderedFromVendorAt, arrivedAtStockAt, installedAt) 的方法。
     - **UI:** 在订单详情页的 OrderItem 列表中，或专门的产品进度跟踪界面，为每个 OrderItem 提供操作来更新其状态（例如，一个按钮或下拉菜单从“未下单”变为“已下单”）。
     - **状态流转限制：** 在 ViewModel 或 Repository 中实现状态不能跨越的逻辑。
  3. **操作人签名记录：**
     - 
     - 在进行状态更新时，获取当前登录的店员 ID (需要先实现店员登录与会话管理)，并记录到 OrderItem.statusLastUpdateStaffId。
  4. **订单完成状态联动：**
     - 
     - 当一个 Order 下的所有 OrderItem 的状态都变为 INSTALLED 时，自动更新 Order.status 为 COMPLETED，并记录 Order.completionDate。同时，触发创建第一条回访计划到 FollowUp 表。
  5. **不同状态列表视图 (可选，但推荐)：**
     - 
     - 创建不同的列表视图来展示处于特定阶段的 OrderItem (如“未下单列表”、“待安装列表”等)，方便商家快速定位和操作。

------



**阶段四：客户回访管理**

- 
- 目标：实现基于订单完成时间和商家设定周期的自动回访提醒和记录。
- **前置依赖：** 订单能被标记为“已完成”并记录完成时间，FollowUp 表结构已定义。
- **具体任务：**
  1. 
  2. **回访计划生成与更新：** (已在 V3 数据库设计中规划)
     - 
     - 当订单完成时，自动创建第一条 FollowUp 记录 (状态 PENDING，scheduledDate 基于 completionDate + 第一个回访间隔)。
     - 当一条 PENDING 的 FollowUp 被标记为 COMPLETED 时，记录实际回访信息，并自动生成下一条 PENDING 的 FollowUp 记录 (基于本次完成时间 + 下一个回访间隔)。
  3. **回访设置界面：**
     - 
     - 允许商家配置回访策略 (如：首次1个月，二次3个月，三次半年等，直到总年限)。这个配置需要存储（可以使用 SharedPreferences 或创建一个简单的配置表）。
  4. **待回访列表与提醒：**
     - 
     - **UI:** 显示所有 status = PENDING 且 scheduledDate <= 当天的 FollowUp 记录。
     - **(高级)** 实现应用内提醒或系统通知 (可能需要 WorkManager 或闹钟服务)。
  5. **执行回访与记录：**
     - 
     - **UI:** 允许商家查看待回访的客户和订单信息，点击“完成回访”后，记录回访日期、操作人、回访内容，并更新 FollowUp 记录状态。
  6. **查看历史回访记录：**
     - 
     - 允许按客户或订单查看所有已完成的回访记录。

------



**阶段五：收款与商家账目**

- 
- 目标：管理订单收款，记录商家收支流水。
- **前置依赖：** 订单管理基础。Payment 和 LedgerEntry 表结构已定义。
- **具体任务：**
  1. 
  2. **收款管理：**
     - 
     - **UI:** 在订单详情页显示应付金额、已付金额、未结款。
     - 提供“添加收款”功能，记录收款金额、日期、方式、收款人，并创建 Payment 记录。
     - 更新订单的已付款信息。
  3. **商家账目记录：**
     - 
     - **UI:** 提供界面查看 LedgerEntry 流水列表 (按日期排序，区分收支)。
     - 允许手动添加支出条目 (如房租、采购成本)。
     - **(可选)** 订单收款 (Payment) 创建时，自动或提示创建一条对应的 INCOME 类型的 LedgerEntry。
  4. **(可选) 简单统计：** 如按日期范围统计总收入、总支出、利润。

------



**阶段六：店员管理与权限 (逐步完善)**

- 
- 目标：管理店员账户，并根据角色实现不同操作权限。
- **前置依赖：** Staff 表结构已定义。
- **具体任务 (初期简化)：**
  1. 
  2. **基础店员管理 UI：** 添加、查看、编辑（如角色、是否激活）、（逻辑）删除店员。
  3. **登录功能 (重要)：**
     - 
     - 实现简单的用户名密码登录。
     - 登录成功后，在应用会话中保存当前登录的 Staff 信息 (ID 和角色)。
  4. **操作记录与签名：** 在关键操作 (订单状态变更、收款、回访记录等) 时，自动记录当前登录的 staffId。
  5. **权限控制 (逐步)：**
     - 
     - **UI层面：** 根据当前登录用户的角色，显示或隐藏某些操作按钮（例如，普通店员不能删除订单，只有老板可以）。
     - **(高级) 后端/逻辑层面：** 在执行敏感操作前，在 ViewModel 或 Repository 中检查用户角色。

------



**实施建议：**

- 
- **导航先行：** 在开始每个新屏幕的开发前，先规划好 Jetpack Navigation Compose 的路由和参数传递。
- **组件化UI：** 对于可复用的 UI 部分（如自定义输入框、列表项、对话框），尽量封装成独立的 @Composable 函数，提高代码复用性和可维护性。
- **状态管理：**
  - 
  - **ViewModel:** 是 UI 状态的主要持有者和管理者。
  - **StateFlow / SharedFlow:** 用于从 ViewModel 向 UI 暴露可观察的数据流和一次性事件。
  - **Compose remember 和 mutableStateOf:** 用于管理 Composable 内部的临时 UI 状态。
- **错误处理：**
  - 
  - 在 ViewModel 和 Repository 层进行恰当的 try-catch 错误捕获。
  - 通过 UI 状态 (如 errorMessage 字段) 将错误信息传递给 UI 层，并以用户友好的方式（如 Snackbar、对话框、错误提示文本）展示。
  - 记录详细的错误日志 (可以使用 Logcat 或集成日志库如 Timber)。
- **协程 (Coroutines):**
  - 
  - 所有耗时操作 (数据库读写、未来可能的网络请求) 都必须在协程中执行，避免阻塞主线程。
  - viewModelScope 用于 ViewModel 中的后台任务。
  - Dispatchers.IO 通常用于数据库操作和网络请求。
- **测试：**
  - 
  - **单元测试:** 对 ViewModel、Repository 中的业务逻辑进行单元测试 (使用 JUnit, Mockito/MockK)。
  - **UI 测试 (Compose):** 对 Composable 函数和屏幕进行 UI 测试 (使用 androidx.compose.ui.test)。
  - **(可选) 集成测试:** 测试多个组件协同工作的场景。
  - 虽然初期可能不会立即投入大量测试，但应有测试意识，关键逻辑优先测试。
- **代码规范与风格：**
  - 
  - 遵循 Kotlin 官方编码规范。
  - 保持代码清晰、可读，添加必要的注释。
  - 定期进行代码审查 (如果团队协作)。
- **版本控制 (Git):**
  - 
  - 为每个主要功能或重要修复创建分支。
  - 频繁提交 (commit) 代码，并编写清晰的提交信息。
  - 定期合并 (merge/rebase) 主开发分支。

------



**阶段七：高级功能与优化 (未来展望)**

在核心功能稳定后，可以考虑以下高级功能和优化，进一步提升应用价值：

- 
- **数据同步与备份 (如果需要多设备或云端)：**
  - 
  - 考虑使用 Firebase Realtime Database/Firestore 或自建后端 API 实现数据云同步。
  - 提供数据备份到云端或本地文件的选项。
- **统计报表：**
  - 
  - 更丰富的销售统计、客户分析、产品畅销排行等报表。
  - 图表化展示数据 (使用 Compose 图表库或集成 MPAndroidChart 等)。
- **库存管理 (如果适用)：**
  - 
  - 管理产品库存数量，与订单关联扣减库存。
  - 低库存提醒。
- **打印功能：**
  - 
  - 打印订单小票、客户信息单等。
- **消息推送与通知：**
  - 
  - 订单状态更新通知客户 (如果客户有APP或通过短信/邮件)。
  - 内部工作流通知 (如新订单分配给店员)。
- **用户体验优化：**
  - 
  - 更精美的 UI 设计和动画效果。
  - 离线支持优化。
  - 性能优化 (Compose 渲染性能、数据库查询优化)。
- **安全性增强：**
  - 
  - 更严格的数据加密 (如果涉及敏感信息)。
  - 用户会话管理和安全退出。
- **多语言支持 (如果目标市场需要)。**

------



**迭代与反馈：**

- 
- **敏捷开发：** 在每个阶段或主要功能点完成后，进行内部测试和（如果可能）小范围用户试用，收集反馈。
- **灵活调整：** 根据反馈和实际使用情况，灵活调整后续功能的优先级和实现细节。
- **与甲方沟通：** 定期向甲方展示阶段性成果，获取确认和新的需求输入，确保项目方向与甲方期望一致。

------



**当前首要任务：**

根据我们之前的讨论，当前最紧迫的任务是**完成阶段一的“客户详情与编辑屏幕”**。这将涉及到：

1. 
2. **引入 Jetpack Navigation Compose** 实现屏幕间的导航。
3. 创建 CustomerDetailViewModel。
4. 设计和实现客户详情/编辑的 Compose UI。

这个规划提供了一个相对完整的蓝图。它强调了模块化和迭代开发，允许我们逐步构建这个功能丰富的 OrderManager 应用。在实际开发过程中，我们可以根据具体情况灵活调整每个阶段的任务和优先级。